################################################################
#
# SEPTEMBER MODULE: runtime
#
# A module that is automatically loaded by the September
# interpreter at startup before handing control over to actual
# September code. Defines basic stuff like loops, control flow
# constructs, and prototypes for primitives (Integer, String,
# etc).
#
################################################################

### Additional object operators (defined based on the native ones)

Object:::"!=" = |other| { !(this == other) }

### Object methods

Object:::resolveAsLiteral = {
	this.resolve(scope: LiteralScope)
}

### Array and object 'literals'

syntax::"[]" = |...___arrayElements| { ___arrayElements }
syntax::"[[]]" = |:::___objectProperties| { ___objectProperties }

### 'class' statement and its components

ClassDefinition := Object()

ClassDefinition:::field = |?name| {
	name = name.resolveAsLiteral()
	cls.accept(name, Slot.field())
}

ClassDefinition:::method = |?name, function = Nothing| {
	name = name.resolveAsLiteral()
	cls.accept(name, Slot.method(function))
}

ClassDefinition:::constructor = |function| {
	cls.accept("<constructor>", Slot.method(function))
}

class := |?name, definition| {
	callingScope := Scopes.caller()
	name = name.resolveAsLiteral()
	
	# create the class
	cls := Class.new(name)
	
	# execute the definition block in the right environment	
	definitionScope := Object()
	definitionScope.prototypes = [ClassDefinition, callingScope]
	definitionScope::cls = cls
	definition.invoke(scope: definitionScope)
	
	# add the class to our caller's scope so that the 
	# statement "class A {...}" actually defines 'A'
	export(cls, as: name)

	return cls
}

#########################################################
# Comparable mixin
#########################################################

## Exception thrown when uncomparable objects are compared with <, >, <= or >=.
class EUncomparable {
	constructor {
		this::message = "These values are not comparable."
	}
}
EUncomparable.prototypes = Exception

comparisonLogic := |relation| {
	return: |other| {
		comparison := this."<compareTo>"(other)
		if (comparison === UncomparableValues) { 
			throw: EUncomparable() 
		}
		return: relation(comparison)
	}
}

## The mixin itself.
class Comparable {
	field UncomparableValues = Nothing
	
 	method "==" |other| { this."<compareTo>"(other) == 0 }
 	method "!=" |other| { this."<compareTo>"(other) != 0 }
 	
 	method "<"  = comparisonLogic |c|{ c < 0 } 
 	method ">"  = comparisonLogic |c|{ c > 0 }
 	method "<=" = comparisonLogic |c|{ c <= 0 }
 	method ">=" = comparisonLogic |c|{ c >= 0 }
}

String.prototypes = Comparable

#########################################################
# Ranges
#########################################################

class Range {
	constructor |start, end, openEnded = False| {
		this::start = start
		this::end = end
		this::openEnded = openEnded
	}
	
	method iterator { RangeIterator(this) }	
}

class RangeIterator {
	constructor |range| {
		this::range = range
		this::current = range.start
	}
	
	method next {
		range_end := if (range.openEnded) { range.end - 1 } else { range.end }
		if (current > range_end) {
			throw: ENoMoreElements()
		} else {
			return_value := current
			current = current + 1
			return: return_value
		}			
	}
}

Integer:::".."  = |end| { Range(this, end) }
Integer:::"..." = |end| { Range(this, end, True) }



