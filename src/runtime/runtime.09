################################################################
#
# SEPTEMBER MODULE: runtime
#
# A module that is automatically loaded by the September
# interpreter at startup before handing control over to actual
# September code. Defines basic stuff like loops, control flow
# constructs, and prototypes for primitives (Integer, String,
# etc).
#
################################################################

### Additional object operators (defined based on the native ones)

Object:::"!=" = |other| { !(this == other) }

### Object methods

Object:::resolveAsLiteral = {
	this.resolve(scope: LiteralScope)
}

### Array and object 'literals'

syntax::"[]" = |...___arrayElements| { ___arrayElements }
syntax::"[[]]" = |:::___objectProperties| { ___objectProperties }

### 'class' statement and its components

ClassDefinition := Object()

ClassDefinition:::field = |?name| {
	name = name.resolveAsLiteral()
	cls.accept(name, Slot.field())
}

ClassDefinition:::method = |?name, function = Nothing| {
	name = name.resolveAsLiteral()
	cls.accept(name, Slot.method(function))
}

ClassDefinition:::constructor = |function| {
	cls.accept("<constructor>", Slot.method(function))
}

class := |?name, definition| {
	callingScope := Scopes.caller()
	name = name.resolveAsLiteral()
	
	# create the class
	cls := Class.new(name)
	
	# execute the definition block in the right environment	
	definitionScope := Object()
	definitionScope.prototypes = [ClassDefinition, callingScope]
	definitionScope::cls = cls
	definition.invoke(scope: definitionScope)
	
	# add the class to our caller's scope so that the 
	# statement "class A {...}" actually defines 'A'
	export(cls, as: name)

	return cls
}

#########################################################
# Comparable mixin
#########################################################

## Exception thrown when uncomparable objects are compared with <, >, <= or >=.
class EUncomparable {
	constructor {
		this::message = "These values are not comparable."
	}
}
EUncomparable.prototypes = Exception

comparisonLogic := |relation| {
	return: |other| {
		comparison := this."<compareTo>"(other)
		if (comparison === UncomparableValues) { 
			throw: EUncomparable() 
		}
		return: relation(comparison)
	}
}

## The mixin itself.
class Comparable {
	field UncomparableValues = Nothing
	
 	method "==" |other| { this."<compareTo>"(other) == 0 }
 	method "!=" |other| { this."<compareTo>"(other) != 0 }
 	
 	method "<"  = comparisonLogic |c|{ c < 0 } 
 	method ">"  = comparisonLogic |c|{ c > 0 }
 	method "<=" = comparisonLogic |c|{ c <= 0 }
 	method ">=" = comparisonLogic |c|{ c >= 0 }
}

#########################################################
# Ranges
#########################################################

class Range {
	constructor |start, end, openEnded = False| {
		this::start = start
		this::end = end
		this::openEnded = openEnded
	}
	
	method iterator { RangeIterator(this) }	
}

class RangeIterator {
	constructor |range| {
		this::range = range
		this::current = range.start
	}
	
	method next {
		range_end := if (range.openEnded) { range.end - 1 } else { range.end }
		if (current > range_end) {
			throw: ENoMoreElements()
		} else {
			return_value := current
			current = current + 1
			return: return_value
		}			
	}
}

Integer:::".."  = |end| { Range(this, end) }
Integer:::"..." = |end| { Range(this, end, True) }

#########################################################
# Strings
#########################################################

String:::join = |sequence| {
	joined := ""
	first := True
	for (item) in (sequence) {
		if (!first) { joined = joined + this } else { first = False }
		joined = joined + item.toString()		
	}
	return: joined
}
String:::toString = { this }

#########################################################
# Sequences
#########################################################

class EOutOfBounds {
	constructor |index| {
		this::message = "Index '" + index.toString() + "' is out of bounds."
	}
}
EOutOfBounds.prototypes = Exception


class Sequence {
	method "[]" |?index| {	
		index = index.resolve(extensions: [[end: -1]])
		if (index.is(Range)) {
			bounds := this.resolveRange(index)
			this.slice(bounds.start, bounds.end)
		} else {
			index = this.resolveIndex(index)
			this.at(index)
		}
	}
	
	method resolveIndex |index| {
		if (index < 0) { this.length() + index } else { index }
	}
	
	method resolveRange |range| {
		start := this.resolveIndex(range.start)  # removing the 'this' here breaks horribly, investigate!
		end := this.resolveIndex(range.end)
		openEnded := range.openEnded	
		
		sequenceLength := this.length()
		if (start < 0) { start = 0 }
		if (end < 0) { end = 0 }
		if (!openEnded) { end = end + 1 } 
		if (start > sequenceLength) { start = sequenceLength }
		if (end > sequenceLength) { end = sequenceLength }	

		return: [[ start: start, end: end ]]
	}
	
	method toString {
		return: ", ".join(this)
	}
	
	method iterator {
		return: SequenceIterator(this)
	}
}

class SequenceIterator {
	constructor |sequence| {
		this::sequence = sequence
		this::current = 0
		this::length = sequence.length()
	}
	
	method next() {
		if (current >= length) { throw: ENoMoreElements() }
		value := sequence.at(current)
		current = current + 1
		return: value
	}
}

#########################################################
# Slices
#########################################################

class Slice {
	constructor |sequence, start, end| {
		this::sequence = sequence
		this::start = start
		this::end = end		
		this::len = if (end > start) { end-start } else { 0 }	
	}
	
	method at |index| {
		if ((index < 0) || (index >= len)) { throw: EOutOfBounds(index) }
		sequence[index + start]
	}	
	method length { len }
}
Slice.prototypes = Sequence


Array:::slice = |start, end| { Slice(this, start, end) }

#########################################################
# Updated prototypes for primitives
#########################################################

String.prototypes = [Comparable, Sequence]
Array.prototypes = Sequence

